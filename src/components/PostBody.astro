---
import htmlRenderer from "@contentful/rich-text-html-renderer";
import { BLOCKS, INLINES } from "@contentful/rich-text-types";
interface Props {
  post: any;
}

const { post } = Astro.props;

const renderInlineAsset = (node) => {
  // image
  if (
    node.nodeType === "embedded-asset-block" &&
    node.data.target.fields.file.contentType.startsWith("image/")
  ) {
    const imgUrl = `https:${node.data.target.fields.file.url}`;
    const imgTitle = node.data.target.fields.title;
    const imgWidth = node.data.target.fields.file.details.image.width;
    const imgHeight = node.data.target.fields.file.details.image.height;

    return ` 
            <picture>
              <source srcset="${imgUrl}?w=800&q=70&fm=avif" media="(max-width: 600px)" />
              <source srcset="${imgUrl}?w=1440&q=70&fm=avif" media="(max-width: 1024px)" />
              <img src="${imgUrl}?w=1600&q=70&fm=avif" alt="${imgTitle || ""}" width="${imgWidth} "height="${imgHeight}" loading="lazy" decoding="async" />
            </picture>
            <p class="img-caption" aria-hidden="true">${imgTitle}</p>
          `;
  }
  if (node.nodeType === "asset-hyperlink") {
    return `
    <a href="${node.data.target.fields.file.url}" download="${node.data.target.fields.title}" class="download-file">
      <svg
        viewBox="0 0 24 24"
        width="24"
        height="24"
        stroke="currentColor"
        stroke-width="2"
        fill="none"
        stroke-linecap="round"
        stroke-linejoin="round"
        class="download-icon"
      >
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
        <polyline points="7 10 12 15 17 10"></polyline>
        <line x1="12" y1="15" x2="12" y2="3"></line>
      </svg>
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="24"
        height="24"
        viewBox="0 0 24 24"
        class="download-spinner"
      >
        <style>
          .download-spinner-animation {
            transform-origin: center;
            animation: spinner_svv2 0.75s infinite linear;
          }
          @keyframes spinner_svv2 {
            100% {
              transform: rotate(360deg);
            }
          }
        </style>
        <path
          d="M10.14,1.16a11,11,0,0,0-9,8.92A1.59,1.59,0,0,0,2.46,12,1.52,1.52,0,0,0,4.11,10.7a8,8,0,0,1,6.66-6.61A1.42,1.42,0,0,0,12,2.69h0A1.57,1.57,0,0,0,10.14,1.16Z"
          class="download-spinner-animation"
          fill="currentColor"
        />
      </svg>
      <span>
      ${node.content[0].value}
      </span>
    </a>`;
  }
  return "";
};

const options = {
  renderNode: {
    [BLOCKS.EMBEDDED_ASSET]: (node) => {
      return renderInlineAsset(node);
    },
    [INLINES.HYPERLINK]: (node) => {
      if (
        node.data.uri.indexOf("youtube") !== -1 &&
        node.content[0].value.indexOf("youtube") !== -1 // only if we embed it with youtube text will be rendered as an iframe
      ) {
        // embed video
        return `	
							<iframe
								data-youtube-embed
								src="${node.data.uri}"
                                frameborder="0"
                                allow="accelerometer; autoplay; encrypted-media; gyroscope;"
                                allowfullscreen
							></iframe>
						`;
      } else {
        // how to render plain links in text
        return `<a href="${node.data.uri}">${node.content[0].value}</a>`;
      }
    },
    [INLINES.ASSET_HYPERLINK]: (node) => {
      return renderInlineAsset(node);
    },
    [BLOCKS.HEADING_2]: (node) => {
      return `<h3>${node.content[0].value}</h3>`;
    },
    [INLINES.ENTRY_HYPERLINK]: (node) => {
      // inline links to other entries
      return `<a href="/${node.data.target.fields.slug}" title="${node.data.target.fields.description}">${node.content[0].value}</a>`;
    },
  },
};
const body = htmlRenderer.documentToHtmlString(post.fields.body, options);
---

<div set:html={body} class="post-html" />

<style media="screen">
  .post-html {
    max-width: 60ch;
  }
  :global(.post-html p) {
    margin-bottom: 2rem;
  }

  :global(.post-html b) {
    color: var(--textAccent);
  }

  :global(.post-html img) {
    display: block;
    background: var(--surfaceAccent);
  }

  :global(.post-html > p:first-of-type::first-letter) {
    color: var(--textAccent);
    initial-letter: 3;
    -webkit-initial-letter: 3;
    font-family: Georgia, "Times New Roman", Times, serif;
    line-height: 0.8em;
    padding-top: 0.5rem;
    padding-right: 1rem;
    padding-bottom: 0.25rem;
  }
  :global(.post-html h3) {
    margin-top: 2rem;
    font-size: 1.1rem;
    margin-bottom: 0.5rem;
  }

  :global(.post-html .img-caption) {
    font-size: 0.75rem;
    margin-top: 0.4rem;

    text-align: right;
  }

  :global(.post-html ul) {
    padding-left: 1rem;
    list-style: disc;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    margin-bottom: 2rem;
  }

  :global(.post-html ul p) {
    margin: 0;
  }

  :global(.post-html li::marker) {
    color: var(--textAccent);
  }

  :global([data-youtube-embed]) {
    aspect-ratio: 16 / 9;
    width: 100%;
  }

  :global(.download-file) {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
  }

  :global(.download-file .download-spinner) {
    display: none;
  }

  :global(.download-file.is-downloading .download-icon) {
    display: none;
  }
  :global(.download-file.is-downloading .download-spinner) {
    display: block;
  }
</style>

<script>
  import JSZip from "jszip";
  import { artificialDelay } from "../lib/utils";

  const downloadButton = document.querySelectorAll(".download-file");

  async function downloadAndCompress(file, filename, type) {
    const remoteFileUrl = file;
    const name = `${filename}.${type}`;

    try {
      await artificialDelay(1000);
      const response = await fetch(remoteFileUrl);
      const fileData = await response.text();
      const fileName = `${filename}.zip`;
      const zip = new JSZip();
      zip.file(name, fileData);
      const zipContent = await zip.generateAsync({
        type: "blob",
        compression: "DEFLATE",
        compressionOptions: { level: 9 },
      });
      const zipUrl = URL.createObjectURL(zipContent);
      const link = document.createElement("a");
      link.href = zipUrl;
      link.download = fileName;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(zipUrl);
    } catch (error) {
      console.error(
        "Errore durante il download o la compressione del file:",
        error
      );
    }
  }

  if (downloadButton.length > 0) {
    downloadButton.forEach((button) => {
      button.addEventListener("click", async function (e) {
        e.preventDefault();
        const oldText = button.querySelector("span").textContent;
        button.querySelector("span").textContent = "Scarico il file...";
        ("Preparo il download...");
        button.classList.add("is-downloading");
        await downloadAndCompress(
          button.getAttribute("href"),
          button.getAttribute("download"),
          "gpx"
        );
        button.classList.remove("is-downloading");
        button.querySelector("span").textContent = oldText;
      });
    });
  }
</script>
